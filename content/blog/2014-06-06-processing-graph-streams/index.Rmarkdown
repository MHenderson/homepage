---
title: Processing Graph Streams
author: Matthew Henderson
date: '2014-06-06'
slug: processing-graph-streams
categories:
  - graph-theory
tags:
  - graph-colouring
  - graphviz
  - gvpr
subtitle: ''
excerpt: 'Introducing gvpr, a graph stream editor from the Graphviz library, by
  presenting a pipeline to apply vertex colourings to graphs in DOT format before
  visualising them with Graphviz.'
draft: no
series: ~
layout: single
---

*gvpr* is a graph stream editor from the [Graphviz](http://www.graphviz.org/) software library.

As an introduction to Graphviz, *gvpr* is probably not an obvious place to start.
So first of all we'll look at a another program from Graphviz, *gc*, which is like a graph version of the Coreutils program *wp*.

After that we'll show how *gc* can be re-implemented as a *gvpr* program.

In the last section we'll show use to use *gvpr* to apply a colouring found by using Joe Culberson's colouring programs to a graph file in DOT format.
In an [earlier post](blog/drawing-coloured-queen-graphs/) we had devised an ad-hoc solution based on Bash and *Sed*.

# Counting Components with *gc*

[GNU Coreutils](https://www.gnu.org/software/coreutils/) is a collection of programs available on any Linux or Unix-based operating system and contains a program [*wc*](https://www.gnu.org/software/coreutils/manual/html_node/wc-invocation.html#wc-invocation) that can be used to count words, lines, or characters in a document.

For example, to calculate the number of lines, words and characters in the *man* page for *wc*:

    $ man wc | wc
         70     252    2133

The Graphviz program, *gc*, is a graph analogue of *wc*.
For graphs in DOT format *gc* can count the number of nodes and edges.

For example, the number of nodes in the [Tutte graph](https://raw.githubusercontent.com/MHenderson/graphs-collection/master/src/Classic/Tutte/tutte.gv):

    $ curl -s gv/tutte.gv | gc -n
          46 %1 (<stdin>)

To calculate the number of edges change the `-n` switch to `-e`:

    $ curl -s gv/tutte.gv | gc -e
          69 %1 (<stdin>)

As with *wc*, if *gc* is given multiple graphs it provides total counts over all input graphs.

    $ cat gv/*.gv | gc -e
          69 %1 (<stdin>)
          18 %141 (<stdin>)
          21 %179 (<stdin>)
         108 total

*gc* can do a few other things beside count nodes and vertices.
It can also count components and clusters (subgraphs labelled as clusters).

## Implementing *gc* in *gvpr*

*gvpr* is like *AWK* but for graphs.
It is a stream editor which can be easily customised for processing graph data in user-defined ways.

There are several simple examples of programs written in *gvpr* in the [*gvpr* manual](http://www.graphviz.org/pdf/gvpr.1.pdf).
One example is the following *gc* clone:

    BEGIN { int n, e; int tot_n = 0; int tot_e = 0;}
    BEG_G {
     n = nNodes($G);
     e = nEdges($G);
     printf("%d nodes %d edges %s\n", n, e, $G.name);
     tot_n += n;
     tot_e += e;
    }
    END { printf("%d nodes %d edges total\n", tot_n, tot_e) }

If the above code is in a file called `gv` and that file is located in a folder on one of the paths in the `GPRPATH` environment variable then it can be invoked by calling `gvpr` and passing the filename `gv` as the argument of the `-f` option.

    $ cat gv/*.gv | gvpr -fgc
    46 nodes 69 edges %1
    12 nodes 18 edges %141
    14 nodes 21 edges %179
    72 nodes 108 edges total

## Programming with *gvpr*

This is roughly how `gv` works.

*gvpr* processes input graphs one at a time.
But before processing any graphs it calls the action of the `BEGIN` clause.
For the `gv` program the `BEGIN` clause is used to initialise some variables used for counting edges and vertices.

Next *gvpr* moves onto processing the first graph. 

When *gvpr* processes a graph it first sets the `$` variable to the current graph before calling the action of the `BEGIN_G` clause.
In the case of *gv*, the `BEGIN_G` clause action calculates the number of edges and vertices of the current graph, prints them out and adds them to the total edge and vertex count.

Having processed the first graph, *gvpr* now repeats the same process for the second graph, third graph and so on.

After the last graph has been processed, *gvpr* calls the action of the `END` clause.
For the `gc` program the `END` clause just prints out the total number of edges and vertices in all input graphs.

## Processing nodes and edges

In the next section we show how to use *gvpr* to take the output of a colouring from *ccli* and apply it to the vertices of a graph before passing it to one of Graphviz's layout programs for drawing.
In this section we introduce the `N` and `E` clauses.

Any number of `N` and `E` clauses can be added to a *gvpr* program to create specific behaviour at nodes and edges.
For example, providing actions to weight a node or edge with a particular value or setting other attributes like the position of a vertex computed by a particular layout algorithm.

`N` and `E` clauses support predicate-action pairs.
If a predicate-action pair is specified then an action will only be run if the predicate belonging to the predicate-action pair is satisfied as well as the main `N` or `E` clause (which is only true when we have encountered a node or edge).

    N [ predicate ]{ action }
    E [ predicate ]{ action }

## Colouring Vertices with *gvpr*

Applying a colouring to a graph in DOT format can be implemented in three lines of *gvpr* code.

    BEG_G { setDflt($, "N", 'colorscheme', 'set13') }
    N { aset($, 'style', 'filled') }
    N { aset($, 'color', ARGV[$.name]) }

There are three clauses: a `BEG_G` clause and two `N` clauses.
The actions for all three clauses call one of two different functions: `setDflt` and `aset`.

The `setDflt` function sets the default value of an attribute.
In the action of the `BEG_G` clause the built-in variable `$` represents the current graph.
The effect of this action is to set the default value of the `colorscheme` attribute for nodes to the `set13` colour scheme.

Graphviz provides [several different colour schemes](http://www.graphviz.org/doc/info/colors.html).
The following quotation from the *gvpr* manual explains how colour schemes work.

> This attribute specifies a color scheme namespace. If defined, it specifies
> the context for interpreting color names. In particular, if a color value
> has form "xxx" or "//xxx", then the color xxx will be evaluated according
> to the current color scheme. If no color scheme is set, the standard X11
> naming is used. For example, if colorscheme=bugn9, then color=7 is
> interpreted as "/bugn9/7".

The `aset` function sets the value of an attribute.
In the body of actions belonging to `N` clauses `aset` will set attributes of nodes.
When *gvpr* processes nodes `$` represents the current node.
So the syntax `aset($, x, y)` assigns the value `y` to the attribute `x`.

We set two attributes for every node.
We set the `style` attribute to `filled` so that when the output graph is rendered by one of the drawing programs in Graphviz the nodes will be drawn as filled-in shapes, making the colour visible.
The other attribute we set for each node is the `color`.
In this case, the `color` is set to a value which is determined by the corresponding value of `ARGV`.

## Example: Colouring the Frucht graph with *gvpr*

To use the above `colour` program, call *gvpr* with `colour` as the argument of the `-f` option.
To provide a vertex-colouring pass a string to *gvpr* as the argument of the `-a` option (this is then available inside of a *gvpr* program as the value of the `ARGV` variable).

    gvpr -f colour -a '1 2 3 1 2 3 2 3 1 3 1 2' gv/frucht.gv > frucht.gv.col

Now applying a colouring to the Frucht graph and drawing it using *twopi* can be done in a pipeline with two steps:

    gvpr -c -f colour -a '1 2 3 1 2 3 2 3 1 3 1 2' gv/frucht.gv |\
    twopi -s\
          -Tpng\
          -Gsize=4,4\!\
          -Groot=3\
          -Nwidth=0.3\
          -Nfixedsize=true\
          -Nlabel=\
          -Nshape=circle\
          -o png/frucht.png

```{r}
#| frucht-colouring,
#| fig.cap="A 3-colouring of the Frucht graph.",
#| fig.align="center",
#| fig.alt="A 3-colouring of the Fruct graph.",
#| echo=FALSE
knitr::include_graphics("img/frucht.png")
```
