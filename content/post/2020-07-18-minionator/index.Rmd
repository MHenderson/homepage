---
title: (WIP) Introducing Minionator
author: Matthew Henderson
date: '2020-07-18'
slug: minionator
categories:
  - constraints
tags:
  - r-packages
  - r
  - minion-r
draft: yes
---

Over the past few weeks
I've been working
on a new R package
for generating constraint programs
for the
[Minion](https://constraintmodelling.org/minion/)
constraint solver.

With Minion you specify
a constraint program
as an input file
and use Minion to find
solutions,
if any exist.

## A very simple constraint program

Here is an example
of a simple Minion input file.

```
MINION 3

**VARIABLES**
DISCRETE l[3,3] {0..2}

**SEARCH**
PRINT ALL

**CONSTRAINTS**
alldiff(l[0,_])
alldiff(l[_,0])
alldiff(l[1,_])
alldiff(l[_,1])
alldiff(l[2,_])
alldiff(l[_,2])

**EOF**
```

This input file
is one possible
way of specifying
a latin square of order 3.

* In the
`**VARIABLES**`
section I specify
a 3 x 3 matrix
of discrete variables
with domain {0 .. 2}.

* In the
`**SEARCH**`
section
I have asked
Minion to print
every solution it finds.

* The
`**CONSTRAINTS**`
are all
`alldiff` constraints.
Here I simply
asking that the symbols
in each row
and each column
are different from each other.
This is just
one way of defining
a latin square.

## Using Minion to find solutions

If the file `ls.minion` contains
this text
then calling minion
with `ls.minion` as the only argument
finds a solution.

```{r}
minion <- "/opt/minion-1.8/bin/minion"

problem_file <- tempfile()
download.file("https://raw.githubusercontent.com/MHenderson/ls-minion/master/3x3_ls.minion", problem_file)

system2(minion, args = problem_file, stdout = TRUE)
```

The solution is given
by lines 16 - 18 of the output
and is,
indeed,
a latin square of order 3.

It can also be used to enumerate (or even explicitly construct) all latin squares of order 3.

```{r}
system2(minion, args = paste("-findallsols -noprintsols", problem_file), stdout = TRUE)
```

Indeed,
[there are 12 latin squares of order 3](https://oeis.org/A002860).

## The Minionator package

The Minionator package I've been working on
helps you to use R to construct such input files.

In Minionator, a constraint program is a list with components variables, search, unary_constraints, binary_constraints etc ....

The variables
and the constraints
are both data frames.

If we want to repeat
the latin square example above
then we need
to begin with a 3x3 matrix
of discrete variables
with domain `{0:2}`.

In Minionator we do
this with the
`discrete_matrix`
function.

```{r, message=FALSE}
library(minionator)
library(tidyverse)

(l <- discrete_matrix(3, 3, 0:2))
```

A constraint in Minionator
is represented by a data frame
with two columns,
`constraint` and `variables`.
The `constraint` column
simply names the constraint
while the `variables`
column is usually a list
of subset of the variable
data frame.

So,
for example,
if I want to
have an alldifferent
constraint over the variables
in row 0
then I can construct
the data frame

```{r}
tribble(
~constraint,             ~variables,
  "alldiff", l %>% filter(row == 0)
  )
```

For the latin square example we need alldiff constraints on the rows and columns of the input matrix.

```{r, message=FALSE}
L <- list(
          variables = l,
             search = "PRINT ALL",
  unary_constraints = tribble(
  ~constraint,             ~variables,
    "alldiff", l %>% filter(row == 0),
    "alldiff", l %>% filter(row == 1),
    "alldiff", l %>% filter(row == 2),
    "alldiff", l %>% filter(col == 0),
    "alldiff", l %>% filter(col == 1),
    "alldiff", l %>% filter(col == 2)
  )
)
```

3x3 latin square in Minionator (without any functions).

To turn this list into a Minion input file we call minion_output(). If we want to write the output to a file as well then we can call write_file() on the output.

```{r}
minion_output(L)
```

So far there isn’t really much point to this. The Minionator list version of the input file is even longer than the Minion input file itself. So why use Minionator?

Suppose now you want to find larger latin squares. If you create a Minion input file by hand then you will have to write a lot more code than the Minionator version. A better approach would be to write a function that generates the output. We can easily write functions to generate the row and column constraints from a parameter equal to the order of the latin square. We don’t even need Minionator to do this but if we are using Minionator then we would end up with something like this.

Code for a parameterised version of the latin square generator.

The benefits of using Minionator don’t stop at just allowing us to create large input files more easily. Perhaps the greatest benefit is that the use of data frames to represent the variables and constraints makes it easier to compose constraints and also to construct constraints over complex variable ranges.

As an example, consider the problem of constructing a pair of mutually orthogonal latin squares of order n. If we are working directly with Minion input files then we would have a lot of cutting-and-pasting to do. With Minionator we can just create two discrete matrices and a function that given a matrix returns the latin constraints for that matrix. Now only the orthogonality question remains.

Code for two latin squares using previously demonstrated latin constraints function.

One approach is to use a constraint on vectors. We can insist that in our solution the pair (i,j) is different to the pair (k,l) whenever i<>j or k<>l. To reduce the number of constraints (not necessarily advantageous) we can also insist that i < k. Tools from the tidyverse make it easy to construct this set of indices. The purrr package then makes it easy to construct from a dataframe of these variables a new dataframe which represents the vector inequality constraint over every pair of pairs.

Code for MOLS.

Calling Minion with this input file we can easily find a pair of mutually orthogonal latin squares of order X. Or even enumerate MOLS of small order.

Calling Minion via R to generate MOLS.

We will look at some more examples now and hope to convince you that using Minionator makes life easier in certain cases. I think having your variables and constraints in data frames makes life a lot easier than if you try to write code to do the same thing with strings and loops etc … The main argument is that the tidyverse and related tools makes it easy to build up the data frame of variables and then to subset it in various complicated ways. Of course you could do it all in your own code working with the output strings directly, but you would probably have to rewrite a lot of code similar to what is already available in the tidyverse (or even just base R). A good example is cross_df.
